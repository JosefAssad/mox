from enum import Enum

import psycopg2
from jinja2 import Template

"""
    GENERAL FUNCTION AND CLASS DEFINITIONS
"""


def get_authenticated_user():
    """Return hardcoded UUID until we get real authentication in place."""
    return "615957e8-4aa1-4319-a787-f1f7ad6b5e2c"


def get_field_names(type):
    """Return the field names from the PostgreSQL type in question.

    TODO: Ask PostgreSQL for the list of fields for the type in question. For
    the time being, just return the names of the fields for "FacetEgenskaber".
    """
    if type == "FacetEgenskaberAttrType":
        return ['brugervendtnoegle', 'facetbeskrivelse', 'facetplan',
                'facetopbygning', 'facetophavsret', 'facetsupplement',
                'retskilde', 'virkning']
    else:
        raise NotImplemented


def convert_attributes(attributes):
    "Convert attributes from dictionary to list in correct order."
    for attr_name in attributes:
        current_attr_periods = attributes[attr_name]
        converted_attr_periods = []
        for attr_period in current_attr_periods:
            current_attr_type = '{0}AttrType'.format(attr_name)
            field_names = get_field_names(current_attr_type)
            attr_value_list = [
                attr_period[f] if f in attr_period else None
                for f in field_names
            ]
            converted_attr_periods.append(attr_value_list)
        attributes[attr_name] = converted_attr_periods
    return attributes


class Livscyklus(Enum):
    OPSTAAET = 'Opstaaet'
    IMPORTERET = 'Importeret'
    PASSIVERET = 'Passiveret'
    SLETTET = 'Slettet'
    RETTET = 'Rettet'


"""
    GENERAL SQL GENERATION.

    All of these functions generate SQL and should maybe be factored to a
    separate "sql.py" module.
"""

def sql_state_array(state, periods):
    """Return an SQL array of type <state>TilsType."""
    with open('templates/sql/state_array.sql', 'r') as f:
        raw_sql = f.read()
    t = Template(raw_sql)
    sql = t.render(state_name=state, state_periods=periods)
    return sql


def sql_attribute_array(attribute, periods):
    """Return an SQL array of type <attribute>AttrType[]."""
    with open('templates/sql/attribute_array.sql', 'r') as f:
        raw_sql = f.read()
    t = Template(raw_sql)
    sql = t.render(attribute_name=attribute, attribute_periods=periods)
    return sql


def sql_relations_array(class_name, relations):
    """Return an SQL array of type <class_name>RelationType[]."""
    with open('templates/sql/relations_array.sql', 'r') as f:
        raw_sql = f.read()
    t = Template(raw_sql)
    sql = t.render(class_name=class_name, relations=relations)
    return sql


def sql_convert_registration(states, attributes, relations, class_name):
    """Convert input JSON to the SQL arrays we need."""
    sql_states = []
    for s, periods in states.iteritems():
        sql_states.append(
            sql_state_array(s, periods)
        )

    sql_attributes = []
    for a, periods in attributes.iteritems():
        sql_attributes.append(
            sql_attribute_array(a, periods)
        )

    sql_relations = sql_relations_array(class_name, relations)

    return (sql_states, sql_attributes, sql_relations)


"""
    FACET RELATED FUNCTIONS
"""


def facet_exists(uuid):
    """Check if a facet with this UUID exists already."""
    # TODO: Implement this!
    non_existing_uuids = ["5da36f77-f8d3-4bfd-b313-cc38e2d667fd"]
    return uuid not in non_existing_uuids


def create_or_import_facet(note, attributes, states, relations, uuid=None):
    """Create a new facet by calling the stored procedure.

    Create a new facet by calling actual_state_create_or_import_facet. It is
    necessary to map the parameters to our custom PostgreSQL data types.
    """

    # Data from the BaseRegistration.
    # Do not supply date, that is generated by the DB.
    life_cycle_code = (Livscyklus.OPSTAAET.value if uuid is None
                       else Livscyklus.IMPORTERET.value)
    user_ref = get_authenticated_user()

    attributes = convert_attributes(attributes)
    (
        sql_states, sql_attributes, sql_relations
    ) = sql_convert_registration(states, attributes, relations, 'Facet')
    with open('templates/sql/create_facet.sql', 'r') as f:
        sql_raw = f.read()
    sql_template = Template(sql_raw)
    sql = sql_template.render(
            uuid=uuid,
            life_cycle_code=life_cycle_code,
            user_ref=user_ref,
            note=note,
            states=sql_states,
            attributes=sql_attributes,
            relations=sql_relations)
    # TODO: Call Postgres! Return OK or not accordingly
    print sql
    return sql


def passivate_facet(note, uuid):
    """Passivate facet by calling the stored procedure."""

    user_ref = get_authenticated_user()
    life_cycle_code = Livscyklus.PASSIVERET.value
    sql_raw = """
    SELECT * FROM actual_state_update_facet(
        '{{ uuid }}',
        '{{ user_ref }}',
        '{{ note }}',
        '{{ life_cycle_code }}',
        null,
        null,
        null);
    """
    sql_template = Template(sql_raw)
    sql = sql_template.render(
            uuid=uuid,
            life_cycle_code=life_cycle_code,
            user_ref=user_ref,
            note=note)
    # TODO: Call PostgreSQL
    print sql
    return sql


def update_facet(note, attributes, states, relations, uuid=None):
    """Update facet with the partial data supplied."""
    life_cycle_code = Livscyklus.RETTET.value
    user_ref = get_authenticated_user()

    attributes = convert_attributes(attributes)

    
    with open('templates/sql/update_facet.sql', 'r') as f:
        sql_raw = f.read()
    sql_template = Template(sql_raw)
    sql = sql_template.render(
            uuid=uuid,
            life_cycle_code=life_cycle_code,
            user_ref=user_ref,
            note=note,
            states=sql_states,
            attributes=sql_attributes,
            relations=sql_relations)
    # TODO: Call Postgres! Return OK or not accordingly
    print sql
    return sql
