from enum import Enum

import psycopg2
from jinja2 import Template

from db_helpers import get_attribute_fields, get_attribute_names
from db_helpers import get_state_names

"""
    GENERAL FUNCTION AND CLASS DEFINITIONS
"""


def get_authenticated_user():
    """Return hardcoded UUID until we get real authentication in place."""
    return "615957e8-4aa1-4319-a787-f1f7ad6b5e2c"


def convert_attributes(attributes):
    "Convert attributes from dictionary to list in correct order."
    for attr_name in attributes:
        current_attr_periods = attributes[attr_name]
        converted_attr_periods = []
        for attr_period in current_attr_periods:
            field_names = get_attribute_fields(attr_name)
            attr_value_list = [
                attr_period[f] if f in attr_period else None
                for f in field_names
            ]
            converted_attr_periods.append(attr_value_list)
        attributes[attr_name] = converted_attr_periods
    return attributes


class Livscyklus(Enum):
    OPSTAAET = 'Opstaaet'
    IMPORTERET = 'Importeret'
    PASSIVERET = 'Passiveret'
    SLETTET = 'Slettet'
    RETTET = 'Rettet'


"""
    GENERAL SQL GENERATION.

    All of these functions generate bits of SQL to use in complete statements.
    At some point, we might want to factor them to an "sql_helpers.py" module.
"""


def sql_state_array(state, periods, class_name):
    """Return an SQL array of type <state>TilsType."""
    with open('templates/sql/state_array.sql', 'r') as f:
        raw_sql = f.read()
    t = Template(raw_sql)
    sql = t.render(class_name=class_name, state_name=state,
                   state_periods=periods)
    return sql


def sql_attribute_array(attribute, periods):
    """Return an SQL array of type <attribute>AttrType[]."""
    with open('templates/sql/attribute_array.sql', 'r') as f:
        raw_sql = f.read()
    t = Template(raw_sql)
    sql = t.render(attribute_name=attribute, attribute_periods=periods)
    return sql


def sql_relations_array(class_name, relations):
    """Return an SQL array of type <class_name>RelationType[]."""
    with open('templates/sql/relations_array.sql', 'r') as f:
        raw_sql = f.read()
    t = Template(raw_sql)
    sql = t.render(class_name=class_name, relations=relations)
    return sql


def sql_convert_registration(states, attributes, relations, class_name):
    """Convert input JSON to the SQL arrays we need."""
    sql_states = []
    for s in get_state_names(class_name):
        periods = states[s] if s in states else []
        sql_states.append(
            sql_state_array(s, periods, class_name)
        )

    sql_attributes = []
    for a in get_attribute_names(class_name):
        periods = attributes[a] if a in attributes else []
        sql_attributes.append(
            sql_attribute_array(a, periods)
        )

    sql_relations = sql_relations_array(class_name, relations)

    return (sql_states, sql_attributes, sql_relations)


"""
    GENRAL OBJECT RELATED FUNCTIONS
"""


def object_exists(class_name, uuid):
    """Check if an object with this class name and UUID exists already."""
    # TODO: Implement this!
    non_existing_uuids = ["5da36f77-f8d3-4bfd-b313-cc38e2d667fd"]
    return uuid not in non_existing_uuids


def create_or_import_object(class_name, note, attributes, states, relations,
                            uuid=None):
    """Create a new object by calling the corresponding stored procedure.

    Create a new object by calling actual_state_create_or_import_{class_name}.
    It is necessary to map the parameters to our custom PostgreSQL data types.
    """

    # Data from the BaseRegistration.
    # Do not supply date, that is generated by the DB.
    life_cycle_code = (Livscyklus.OPSTAAET.value if uuid is None
                       else Livscyklus.IMPORTERET.value)
    user_ref = get_authenticated_user()

    attributes = convert_attributes(attributes)
    (
        sql_states, sql_attributes, sql_relations
    ) = sql_convert_registration(states, attributes, relations, class_name)
    with open('templates/sql/create_object.sql', 'r') as f:
        sql_raw = f.read()
    sql_template = Template(sql_raw)
    sql = sql_template.render(
            class_name=class_name,
            uuid=uuid,
            life_cycle_code=life_cycle_code,
            user_ref=user_ref,
            note=note,
            states=sql_states,
            attributes=sql_attributes,
            relations=sql_relations)
    # TODO: Call Postgres! Return OK or not accordingly
    print sql
    return sql


def passivate_object(class_name, note, uuid):
    """Passivate object by calling the stored procedure."""

    user_ref = get_authenticated_user()
    life_cycle_code = Livscyklus.PASSIVERET.value
    with open('templates/sql/passivate_object.sql', 'r') as f:
        sql_raw = f.read()
    sql_template = Template(sql_raw)
    sql = sql_template.render(
            class_name=class_name,
            uuid=uuid,
            life_cycle_code=life_cycle_code,
            user_ref=user_ref,
            note=note)
    # TODO: Call PostgreSQL
    print sql
    return sql


def update_object(class_name, note, attributes, states, relations, uuid=None):
    """Update object with the partial data supplied."""
    life_cycle_code = Livscyklus.RETTET.value
    user_ref = get_authenticated_user()

    attributes = convert_attributes(attributes)
    (
        sql_states, sql_attributes, sql_relations
    ) = sql_convert_registration(states, attributes, relations, class_name)

    with open('templates/sql/update_object.sql', 'r') as f:
        sql_raw = f.read()
    sql_template = Template(sql_raw)
    sql = sql_template.render(
            class_name=class_name,
            uuid=uuid,
            life_cycle_code=life_cycle_code,
            user_ref=user_ref,
            note=note,
            states=sql_states,
            attributes=sql_attributes,
            relations=sql_relations)
    # TODO: Call Postgres! Return OK or not accordingly
    print sql
    return sql
